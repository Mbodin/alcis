\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{a4wide}
\usepackage{pstricks}
\usepackage{lmodern}
\usepackage{stmaryrd}
\usepackage{amsmath, amsthm}
\usepackage{amsfonts, amssymb}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{array}
\usepackage{hyperref}
\usepackage{wasysym}
\usepackage{listings}

\definecolor{darkblue}{rgb}{0,0,.5}
\hypersetup{unicode=true, colorlinks=false}

\renewcommand{\ge}{\geqslant}
\renewcommand{\le}{\leqslant}
\renewcommand{\preceq}{\preccurlyeq}
\renewcommand{\succeq}{\succcurlyeq}

\newcommand{\Alcis}{\textsc{Alcis}~}
\renewcommand{\C}{\textsc{C}~}

\newcommand{\FIXME}{~\textbf{FIXME}~}

\title{\Alcis Standards}
\author{Martin \textsc{Bodin}}
\date{}


\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\paragraph{Introduction}
{
    The language \Alcis is compiled to a \C code.
    It’s main feature is to permit the programmer to create notations at will.
    It’s a strong typed, object-oriented language.
    It has been design to be soft and easy to code with.
}

\section{Files Types}

Here are the list of all the type of \Alcis files there exists:
\begin{itemize}
    \item \Alcis Header. It contains prototypes of functions and variables, and contains parsing informations.
    \item \Alcis Source Code. It contains declarations of functions and variables.
    \item \Alcis Compiled Interface. It contains the \C equivalent of a group of function and variables.
\end{itemize}

There is no extensions forced with thoses different types of files\footnote
{
    In fact \Alcis is design to manipulate extensionless files.
}, but in the case an extension is needed (for instance in the case of the use of a Makefile), here is the advised extension for the \Alcis files:

\begin{center}\begin{tabular}{|c||c|}
\hline File & Extension \\
\hline \Alcis Header & \tt .ah \\
\hline \Alcis Source Code & \tt .ac \\
\hline \Alcis Compiled Interface & \tt .ai \\
\hline \C Header & \tt .h \\
\hline \C Source Code & \tt .c \\
\hline
\end{tabular}\end{center}

\section{\Alcis Header}

An \Alcis header is a succession of prototypes and priorities.

(And files including using the keyword \texttt{needed})

\subsection{prototypes}

A prototype is a way to express that the type of a function or a variable.

It is expressed by:
\[
    <type>~\textrm{\tt:}~<variable>
\]

In the case of a function, by:
\[
    <function~type>~\textrm{\tt->}~<returned~type>~\textrm{\tt:}~<function>
\]

The function type indicate the way the function is called.
It’s expressed by a succession of types and keyword \lstinline$fun$.
In the second part of the expression (after the keyword \lstinline$:$) — in the same order — the function argument and function name are writen.
It is possible not to name something (for instance argument): it is done simply by naming it \texttt{\_}.
For instance a function \lstinline$f$ that takes one integer to the right as an argument can be expressed by
\begin{lstlisting}
fun int : f _
\end{lstlisting}

When a function takes more than one arguments, it is possible to set a prioroty between these argument (for parsing).
It is done by writing the type of the corresponding argument between \lstinline$<<<$ and \lstinline$>>>$.
For instance, if a prototype is declared with
\begin{lstlisting}
int fun <<< int >>> fun int -> int : _ # _ # _
\end{lstlisting}
Then the expression \lstinline$1 # 2 # 3 # 4 # 5$ means \lstinline$1 # (2 # 3 # 4) # 5$.
If no priority is defined and that the compiler meet ambigous expression (such as the one defined later), then an error should happen.

Note that there must be at least one keyword \lstinline$fun$ in a functional type, but that there not necessarily an argument.
For instance, the following code is correct:
\begin{lstlisting}
fun -> int : counter
\end{lstlisting}
The function is then called whenever the variable is written.
Such functions are unadvised because of the difficulty to understand a code they raise, but are accepted for the completeness of the language.

When there is a succession of functionnal type, the keyword \lstinline$->$ has a right priority: \lstinline$a -> b -> c$ means \lstinline$a -> (b -> c)$.

It is possible to put an expression inside parenthesis to indicate a type if this expression returns a type. The parenthesis are there unoptionnal.
Thus, even if \lstinline$f$ has the type (for instance) \lstinline$fun int -> type$, it is impossible to write \lstinline$f 0 : a$.
It can be writen nonetheless \lstinline$(f 0) : a$.

\subsection{priorities}

\FIXME

\section{\Alcis Source Code}

\FIXME

\section{\Alcis Compiled Interface}

\FIXME

\section{List of Reserved Keyword}

\FIXME

\section{Standard Library}

\FIXME: the loop for, while ; strings, lists ; the operators +, *, \ldots

\end{document}

