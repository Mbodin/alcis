\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{a4wide}
\usepackage{pstricks}
\usepackage{lmodern}
\usepackage{stmaryrd}
\usepackage{amsmath, amsthm}
\usepackage{amsfonts, amssymb}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{array}
\usepackage{hyperref}
\usepackage{wasysym}
\usepackage{listings}

\definecolor{darkblue}{rgb}{0,0,.5}
\hypersetup{unicode=true, colorlinks, linkcolor=black}

\lstdefinelanguage{alcis}
{
	keywords={fun,->,:,<<<,>>>},
    morekeywords={int},
	sensitive,
	comment=[s]{(*}{*)}
}

\lstset
{
	numbers=left,
	numberstyle=\tiny,
	language=alcis,
	tabsize=2
}


\renewcommand{\ge}{\geqslant}
\renewcommand{\le}{\leqslant}
\renewcommand{\preceq}{\preccurlyeq}
\renewcommand{\succeq}{\succcurlyeq}

\newcommand{\Alcis}{\textsc{Alcis}~}
\renewcommand{\C}{\textsc{C}~}

\newcommand{\FIXME}{~\textbf{FIXME}~}

\title{\Alcis Standards}
\author{Martin \textsc{Bodin}}
\date{}


\begin{document}

\maketitle

\newpage

\tableofcontents

\newpage

\paragraph{Introduction}
{
    The language \Alcis is compiled to a \C code.
    It’s main feature is to permit the programmer to create notations at will.
    It’s a strong typed, object-oriented language.
    It has been design to be soft and easy to code with.
}

\section{Files Types}

Here are the list of all the type of \Alcis files there exists:
\begin{itemize}
    \item \Alcis Header. It contains prototypes of functions and variables, and contains parsing informations.
    \item \Alcis Source Code. It contains declarations of functions and variables.
    \item \Alcis Compiled Interface. It contains the \C equivalent of a group of function and variables.
\end{itemize}

There is no extensions forced with thoses different types of files\footnote
{
    In fact \Alcis is design to manipulate extensionless files.
}, but in the case an extension is needed (for instance in the case of the use of a Makefile), here is the advised extension for the \Alcis files:

\begin{center}\begin{tabular}{|c||c|}
\hline File & Extension \\
\hline \Alcis Header & \tt .ah \\
\hline \Alcis Source Code & \tt .ac \\
\hline \Alcis Compiled Interface & \tt .ai \\
\hline \C Header & \tt .h \\
\hline \C Source Code & \tt .c \\
\hline
\end{tabular}\end{center}

\section{Common standard}

Whatever the file type, commentary are expressed by \lstinline$(*$ and \lstinline$*)$.
It is possible to put commentary inside commentary. (As in \textsc{OCaml})

\FIXME

\section{\Alcis Header}

An \Alcis header is a succession of prototypes and priorities.

(And files including using the keyword \texttt{needed})

\subsection{prototypes}

A prototype is a way to express that the type of a function or a variable.

It is expressed by:
\[
    <type>~\textrm{\tt:}~<variable>
\]

In the case of a function, by:
\[
    <function~type>~\textrm{\tt->}~<returned~type>~\textrm{\tt:}~<function>
\]

The function type indicate the way the function is called.
It’s expressed by a succession of types and keyword \lstinline$fun$.
In the second part of the expression (after the keyword \lstinline$:$) — in the same order — the function argument and function name are writen.
It is possible not to name something (for instance argument): it is done simply by naming it \lstinline$_$.
For instance a function \lstinline$f$ that takes one integer to the right as an argument can be expressed by
\begin{lstlisting}
fun int : f _
\end{lstlisting}

When a function takes more than one arguments, it is possible to set a prioroty between these argument (for parsing).
It is done by writing the type of the corresponding argument between \lstinline$<<<$ and \lstinline$>>>$.
For instance, if a prototype is declared with
\begin{lstlisting}
int fun <<< int >>> fun int -> int : _ # _ # _
\end{lstlisting}
Then the expression \lstinline$1 # 2 # 3 # 4 # 5$ means \lstinline$1 # (2 # 3 # 4) # 5$.
If no priority is defined and that the compiler meet ambigous expression (such as the one defined later), then an error should happen.

Note that there must be at least one keyword \lstinline$fun$ in a functional type, but that there not necessarily an argument.
For instance, the following code is correct:
\begin{lstlisting}
fun -> int : counter
\end{lstlisting}
The function is then called whenever the variable is written.
Such functions are unadvised because of the difficulty to understand a code they raise, but are accepted for the completeness of the language.

When there is a succession of functionnal type, the keyword \lstinline$->$ has a right priority: \lstinline$a -> b -> c$ means \lstinline$a -> (b -> c)$.

It is possible to put an expression inside parenthesis to indicate a type if this expression returns a type. The parenthesis are there unoptionnal.
Thus, even if \lstinline$f$ has the type (for instance) \lstinline$fun int -> type$, it is impossible to write \lstinline$f 0 : a$.
It can be writen nonetheless \lstinline$(f 0) : a$.

\subsection{priorities}

Priorities are to define function priorities when parsing.
If there is no priority define to desambigous an ambigious expression, this expression is to be refused by the compiler.
For instance the code \lstinline$1 + 2 * 3$ won’t work if the header defining \lstinline$+$ and \lstinline$*$ is just
\begin{lstlisting}
int fun int -> int : _ + _
int fun int -> int : _ * _
\end{lstlisting}
There must be a priority defined, or parenthesis.

A priority is defined by one of the followings patterns:
\[
    <operator~1>~\textrm{\lstinline$>>>$}~<operator~2>
\]
\[
    <operator~2>~\textrm{\lstinline$<<<$}~<operator~1>
\]
Which mean that the operator $1$ has a higer priority of the operator $2$.

The operator is defined by replacing all the \lstinline$fun$ of its functionnal type by the proper name.

For instance, to set a higher priority for \lstinline$*$ than \lstinline$+$, the following line have to be added in a header:
\begin{lstlisting}
int * int >>> int + int
\end{lstlisting}

\section{\Alcis Source Code}

There is two things in those files: definitions and expressions.

Definitions associate the code of a function or variable.
They looks like prototypes of headers, but are followed by the symbol \lstinline$=$, then by the expression which will be the definition of the function or variable.
There can be only one definition for all function and variables.

The expressions directly in all the \Alcis source code will be executed at the beginning of the program, in the order they appear in the code.
But there is no rules for the execution order of the expressions that appear in two different source files.
The compiler will then refuse such a code with an undefined behaviour.

\section{\Alcis Compiled Interface}

\FIXME

\section{List of Reserved Keyword}

\FIXME

\section{Standard Library}

\FIXME: the loop for, while ; strings, lists ; the operators +, *, \ldots

\end{document}

